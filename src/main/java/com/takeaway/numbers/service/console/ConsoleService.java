package com.takeaway.numbers.service.console;

import com.takeaway.numbers.cache.ApplicationCache;
import com.takeaway.numbers.eventbus.EventStore;
import com.takeaway.numbers.eventbus.Producer;
import com.takeaway.numbers.eventbus.event.NumberGeneratedEvent;
import com.takeaway.numbers.service.console.commands.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class ConsoleService {
    public static final String SUPPORTED_GAME_MODES = "Numbers Game - Choose game mode%n";
    public static final String MODE_A = "A (Auto play - numbers will be auto-generated)%n";
    public static final String MODE_M = "M (Manual play - you will be prompted to enter numbers)%n";
    public static final String CMD_Q = "Q (Exit the game)%n";
    public static final String ENTER_MODE = "Enter Game Mode:%n";
    public static final String ENTER_NUMBER_TO_ADD = "Add -1, 0 or 1 to make %s divisible by 3:%n";
    public static final String ENTER_POSITIVE_WHOLE_NUMBER = "Enter positive whole number:%n";
    public static final String NUMBER_GENERATED = "Number %s generated by %s; previous number: %s; added number: %s%n";
    public static final String WINNER_MESSAGE = "%s Won! Enter R (Restart the game) or Q (Quit the game):%n";
    public static final String UNSUPPORTED_VALUE_ENTERED = "Unsupported value entered, try again:%n";
    public static final String WAITING_FOR_PLAYER_TO_START = "Waiting for player %s to start%n";
    private Scanner scanner;
    @Autowired
    private Producer producer;
    @Autowired
    private ApplicationCache applicationCache;
    @Autowired
    private EventStore eventStore;

    public ConsoleService() {
        scanner = new Scanner(System.in);
    }

    public synchronized void startGame() {
        System.out.printf(SUPPORTED_GAME_MODES);
        System.out.printf(MODE_A);
        System.out.printf(MODE_M);
        System.out.printf(CMD_Q);
        System.out.printf(ENTER_MODE);
        String consoleInput = scanner.nextLine();
        while (!matchAndExecute(new Command[]{new AutoModeCommand(),
                new ManualModeCommand(), new QuitCommand()}, consoleInput)) {
            System.out.printf(UNSUPPORTED_VALUE_ENTERED);
            consoleInput = scanner.nextLine();
        }
    }

    public synchronized void addNumber() {
        System.out.printf(ENTER_NUMBER_TO_ADD, applicationCache.getCurrentNumber());
        String consoleInput = scanner.nextLine();
        while (!matchAndExecute(new Command[]{new NumberToAddCommand()}, consoleInput)) {
            System.out.printf(UNSUPPORTED_VALUE_ENTERED);
            consoleInput = scanner.nextLine();
        }
    }

    public synchronized void enterPositiveWholeNumber() {
        System.out.printf(ENTER_POSITIVE_WHOLE_NUMBER);
        String consoleInput = scanner.nextLine();
        while (!matchAndExecute(new Command[]{new PositiveWholeNumberCommand()}, consoleInput)) {
            System.out.printf(UNSUPPORTED_VALUE_ENTERED);
            consoleInput = scanner.nextLine();
        }
    }

    public synchronized void numberGenerated(NumberGeneratedEvent numberGeneratedEvent) {
        System.out.printf(NUMBER_GENERATED, numberGeneratedEvent.getResultingNumber(),
                numberGeneratedEvent.getInstanceType(), numberGeneratedEvent.getPreviousNumber(),
                numberGeneratedEvent.getAddedNumber());
    }

    public synchronized void winner(NumberGeneratedEvent numberGeneratedEvent) {
        System.out.printf(WINNER_MESSAGE, numberGeneratedEvent.getInstanceType().
                equals(applicationCache.getServiceInstance()) ? "You" : numberGeneratedEvent.getInstanceType());
        String consoleInput = scanner.nextLine();
        while (!matchAndExecute(new Command[]{new RestartCommand(),
                new QuitCommand()}, consoleInput)) {
            System.out.printf(UNSUPPORTED_VALUE_ENTERED);
            consoleInput = scanner.nextLine();
        }
    }

    public synchronized void waitingForPlayerToStart() {
        System.out.printf(WAITING_FOR_PLAYER_TO_START, applicationCache.getPeerInstance());
    }

    public boolean matchAndExecute(Command[] commands, String consoleInput) {
        boolean result = false;
        for (Command command : commands) {
            Pattern pattern = Pattern.compile(command.getRegex());
            Matcher matcher = pattern.matcher(consoleInput);
            if (matcher.find()) {
                command.execute(producer, matcher, this, applicationCache, eventStore);
                result = true;
            }
        }
        return result;
    }
}
